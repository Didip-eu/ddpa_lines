 #!/usr/bin/env python3

"""
Leeches Monasterium's backend xml-database files to construct target file structure system.
"""

#TODO: use md5 and hashing for substituting screwed strings 
#TODO: move some functions to ddp_util
#TODO: add "url2path_idx_path":"{root_dir}/url2path_idx.pickle" + code; checking dependencies etc. 
#TODO: discuss:
# - if we include data types in function documentation, we should do it consistently, right? what is best practice?

import os
import random
from pathlib import Path
from pathlib import PurePosixPath
from pprint import pprint
from lxml import etree
import shutil
import fargv
from tqdm import tqdm


def get_path_generator(directory, file_extension):  
    """
    Returns Generator of file paths in (sub)directories.
    @rtype Generator
    """
    for entry in os.scandir(directory):
        if entry.is_file() and entry.name.endswith(file_extension):
            yield Path(entry.path) 
        elif entry.is_dir():
            yield from get_path_generator(entry.path, file_extension)
        else:
            continue


def get_path_list(directory, file_extension):
    """
    Returns List containing file paths.
    @rtype List
    """
    paths = [f"{PurePosixPath(path)}" for path in get_path_generator(directory, file_extension)]
    return random.sample(paths, 100)
    #return paths


def get_atomid_dict(paths): 
    """
    Returns unique ids from xml-cei files.
    @rtype Dict
    """
    pprint("Parsing .cei.xml for atomids.")
    atomids = {}
    for file in tqdm(paths):
        with open(file, 'r', encoding='utf-8') as current:
            tree = etree.parse(current)
            root = tree.getroot()
            atomids[file] = root[0].text
    return atomids


def move_charter_files(locations, target_directory):
    """
    Takes dictionary with path key to atomid as locations.
    Builds (sub)directory structure at target based on (length of) atomids.
    """
    pprint("Building target directories; copying files.")
    for path, atomid in tqdm(locations.items()):
        parts = atomid.split("/")
        filename = os.path.basename(path)
        if len(parts) == 5:
            target_path = f"{target_directory}/{parts[2]}/{parts[3]}/{parts[4]}"
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            shutil.copy(path, target_path + filename)
        else:
            target_path = f"{target_directory}/COLLECTIONS/{parts[2]}/{parts[3]}"
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            shutil.copy(path, target_path + filename)


def move_collection_files(locations, target_directory): 
    """
    Takes dictionary with path key to atomid as locations.
    Builds (sub)directory structure at target based on atomids.
    """
    pprint("Building target directories; copying files.")
    for path, atomid in tqdm(locations.items()):
        parts = atomid.split("/")
        filename = os.path.basename(path)
        if len(parts) == 5: #archive
            target_path = f"{target_directory}/{parts[2]}/{parts[3]}/{parts[4]}" #TODO:
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            shutil.copy(path, target_path + filename)
        else: #collection
            target_path = f"{target_directory}/COLLECTIONS/{parts[2]}/{parts[3]}"
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            shutil.copy(path, target_path + filename)


# goal: put ead/preferences info etc. into directory structure (so it makes sense, and the query can be: look for this file in parent folder---)
# re-use functions here: path_generator 
# first, look at notebook for info how to

# 1) leech into list
# 2) write into json (with indent)
# 3) put into json at collection level





if __name__ == "__main__":
    p={
            "root_dir": ".", 
            "charter_dir": "{root_dir}/data/db/mom-data/metadata.charter.public",
            "collection_dir": "{root_dir}/data/db/mom-data/metadata.collection.public",
            "target_dir": "{root_dir}/data/tmp/data/leech_db",
            #"file_ext": ".cei.xml"
            
    }
    
    #params
    args, _ = fargv.fargv(p) 

    #leech and move charters
    charter_paths = get_path_list(args.charter_dir, ".cei.xml")
    atom_id_dict = get_atomid_dict(charter_paths)
    move_charter_files(atom_id_dict, args.target_dir)

    #leech and move collection data
    collection_paths = get_path_list(args.collection_dir, ".cei.xml")
    atom_id_dict = get_atomid_dict(collection_paths)
    move_collection_files(atom_id_dict, )







    #leech and move archive/fond data


# TODO: convention for docstring writing, see https://www.datacamp.com/tutorial/docstrings-python; and include datatypes