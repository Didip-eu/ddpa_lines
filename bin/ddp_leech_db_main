 #!/usr/bin/env python3

"""
Leeches Monasterium's backend xml-database files to construct target file structure system.
"""

#TODO: use md5 and hashing for substituting screwed strings
#TODO: fix permissions or make choices available in fargv for different file writing permission modes (https://stackoverflow.com/questions/5231901/permission-problems-when-creating-a-dir-with-os-makedirs-in-python)
#TODO: move some functions to ddp_util
#TODO: add "url2path_idx_path":"{root_dir}/url2path_idx.pickle" + code; checking dependencies etc. 
#TODO: discuss in group:
# - if we include data types in function documentation, we should do it consistently, right? what is best practice?
# - convention for docstring writing, see https://www.datacamp.com/tutorial/docstrings-python; and include datatypes

import os
import random
from pathlib import Path
from pathlib import PurePosixPath
from pprint import pprint
from lxml import etree
import shutil
import fargv
from tqdm import tqdm
import math


def get_path_generator(directory, file_extension):  
    """
    Returns Generator of file paths in (sub)directories.
    @rtype Generator
    """
    for entry in os.scandir(directory):
        if entry.is_file() and entry.name.endswith(file_extension):
            yield Path(entry.path) 
        elif entry.is_dir():
            yield from get_path_generator(entry.path, file_extension)
        else:
            continue


def get_path_list(directory, file_extension):
    """
    Returns List containing file paths.
    @rtype List
    """
    paths = [f"{PurePosixPath(path)}" for path in get_path_generator(directory, file_extension)]
    return random.sample(paths, 50)
    #return paths


def get_atomid_dict(paths): 
    """
    Returns unique ids from xml-cei files.
    @rtype Dict
    """
    pprint("Parsing .cei.xml for atomids.")
    atomids = {}
    for file in tqdm(paths):
        with open(file, 'r', encoding='utf-8') as current:
            tree = etree.parse(current)
            root = tree.getroot()
            atomids[file] = root[0].text
    return atomids


def move_charter_files(locations, target_directory):
    """
    Takes dictionary with path key to atomid as locations.
    Builds (sub)directory structure at target based on (length of) atomids.
    """
    pprint("Building target directories; copying files.")
    for path, atomid in tqdm(locations.items()):
        parts = atomid.split("/")
        if len(parts) == 5:
            target_path = f"{target_directory}/{parts[2]}/{parts[3]}/{parts[4]}"
            print(target_path)
            os.makedirs(target_path, exist_ok=True)
            shutil.copy(path, target_path)
        else:
            target_path = f"{target_directory}/COLLECTIONS/{parts[2]}/{parts[3]}"
            print(target_path)
            os.makedirs(target_path, exist_ok=True)
            shutil.copy(path, target_path)


def move_collection_files(locations, target_directory): 
    pprint("Building target directories; copying files.")
    for path, atomid in tqdm(locations.items()):
        parts = atomid.split("/")
        target_path = f"{target_directory}/COLLECTIONS/{parts[2]}"
        print(target_path)
        os.makedirs(target_path, exist_ok=True)
        shutil.copy(path, target_path)


if __name__ == "__main__":
    p={
            "root_dir": ".", 
            "charter_dir": "{root_dir}/data/db/mom-data/metadata.charter.public",
            "collection_dir": "{root_dir}/data/db/mom-data/metadata.collection.public",
            "archive_dir": "{root_dir}/data/db/mom-data/metadata.archive.public",
            "target_dir": "{root_dir}/data/tmp/data/leech_db"
            #"file_ext": ".cei.xml"   
    }
    
    #params
    args, _ = fargv.fargv(p) 

    #charters
    charter_paths = get_path_list(args.charter_dir, ".cei.xml")
    atom_id_dict = get_atomid_dict(charter_paths)
    move_charter_files(atom_id_dict, args.target_dir)

    #collections
    collection_paths = get_path_list(args.collection_dir, ".cei.xml")
    atom_id_dict = get_atomid_dict(collection_paths)
    move_collection_files(atom_id_dict, args.target_dir)



# TODO: make same structure for archive, fond, then check how they can fit in one function (move files)

    #archives
    # put ead/preferences info etc. into directory structure (so querying for parent folder is possible
    archive_paths = get_path_list(args.archive_dir, )

    #fonds
    # here we find the image base (name of fond.prferences.xml ..)
