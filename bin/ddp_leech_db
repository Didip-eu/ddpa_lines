 #!/usr/bin/env python3

import os
import random
from pathlib import Path
from pathlib import PurePosixPath
from pprint import pprint
from lxml import etree
import re
import shutil
import fargv


def get_path_generator(directory, file_extension): 
    """
    returns Generator of file paths in (sub)directories
    @rtype Generator
    """
    for entry in os.scandir(directory):
        if entry.is_file() and entry.name.endswith(file_extension):
            yield Path(entry.path) 
        elif entry.is_dir():
            yield from get_path_generator(entry.path, file_extension)
        else:
            continue


def get_path_list(directory, file_extension):
    """
    returns List containing file paths
    @rtype List
    """
    paths = [f"{PurePosixPath(path)}" for path in get_path_generator(directory, file_extension)]

    return random.sample(paths, 100)
    #return paths


def get_charter_atomid_dict(paths): #if we include data types in functions, we should do it consistently - decide on this?
    """
    returns unique ids from xml-cei files
    @rtype Dict
    """
    atom_ids = {}
    for file in paths:
        with open(file, 'r', encoding='utf-8') as current:
            tree = etree.parse(current)
            root = tree.getroot()
            atom_ids[file] = root[0].text
    return atom_ids


def move_files(locations, target_directory): #maybe refactor so every function uses same names, e.g. locations everywhere, not atom_ids list or dict etc.
    """
    reads directory containg file path -> key and atomid -> value
    missing folders and files will be added to the target archive or collection
    """
    pattern = re.compile("^tag:[a-zA-Z0-9.,:-]+/[a-zA-Z0-9.,:-]+/[a-zA-Z0-9.,:-]+/"
                         "[a-zA-Z0-9.,:_-]+$")
    for path, atom in locations.items():
        collection = f"{target_directory}/main/collections/"
        archive = f"{target_directory}/main/archive/"
        folder = os.path.basename(os.path.dirname(path))
        archive_path = os.path.basename(os.path.dirname(os.path.dirname(path)))
        filename = os.path.basename(path)
        
        print("______")
        print(f"collection:{collection}")
        print(f"archive:{archive}")
        print(f"archive_path:{archive_path}")
        print(f"folder:{folder}")
        print(f"filename:{filename}")

        if pattern.match(atom) is not None:
            if not os.path.exists((collection + "/" + folder)):
                os.makedirs(collection + "/" + folder)
        if pattern.match(atom) is not None:
            if not os.path.exists(collection + "/" + folder + "/" + filename):
                shutil.copy(path, (collection + "/" + folder + "/" + filename))
        elif not os.path.exists(archive + archive_path):
            os.makedirs(archive + archive_path)
        elif not os.path.exists(archive + archive_path + "/" + folder):
            os.makedirs(archive + archive_path + "/" + folder)
        elif not os.path.exists(archive + archive_path + "/" + folder + "/" + filename):
            shutil.copy(path, (archive + archive_path + "/" + folder + "/" + filename))


def create_directories(target_directory):
    """
    create collections / archives folders
    """
    if not os.path.exists(f"{target_directory}/main/collections"):
        os.makedirs(f"{target_directory}/main/collections")
    if not os.path.exists(f"{target_directory}/main/archive/"):
        os.makedirs(f"{target_directory}/main/archive/")


if __name__ == "__main__":
    p={
            "root_dir": ".", 
            "charter_dir": "{root_dir}/data/db/mom-data/metadata.charter.public", 
            "target_dir": "{root_dir}/data/tmp/data/leech_db",
            "file_ext": ".cei.xml"
    }
    args, _ = fargv.fargv(p) #Q: what is it that prevents improved linting for this module? e.g., when an arg is not in args -> p?; especially when nesting variables, e.g., building paths from root

    create_directories(args.target_dir)
    charter_paths = get_path_list(args.charter_dir, args.file_ext)
    atom_id_dict = get_charter_atomid_dict(charter_paths)
    move_files(atom_id_dict, args.target_dir)
