 #!/usr/bin/env python3

import os
import random
from pathlib import Path
from pathlib import PurePosixPath
from pprint import pprint
from lxml import etree
import re
import shutil
import fargv
from tqdm import tqdm


def get_path_generator(directory, file_extension): 
    """
    Returns Generator of file paths in (sub)directories.
    @rtype Generator
    """
    for entry in os.scandir(directory):
        if entry.is_file() and entry.name.endswith(file_extension):
            yield Path(entry.path) 
        elif entry.is_dir():
            yield from get_path_generator(entry.path, file_extension)
        else:
            continue


def get_path_list(directory, file_extension):
    """
    Returns List containing file paths.
    @rtype List
    """
    paths = [f"{PurePosixPath(path)}" for path in get_path_generator(directory, file_extension)]
    return random.sample(paths, 1000)
    #return paths


def get_charter_atomid_dict(paths): #TODO if we include data types in functions, we should do it consistently - discuss this?
    """
    Returns unique ids from xml-cei files.
    @rtype Dict
    """
    pprint("Parsing .cei.xml for atomids.")
    atomids = {}
    for file in tqdm(paths):
        with open(file, 'r', encoding='utf-8') as current:
            tree = etree.parse(current)
            root = tree.getroot()
            atomids[file] = root[0].text
    return atomids


def move_files(locations, target_directory): #TODO maybe refactor so every function uses same names, e.g. locations everywhere, not atom_ids list or dict etc.
    """
    Takes dictionary with path key to atomid as locations.
    Builds (sub)directory structure at target based on atomids.
    """
    pprint("Building target directories; copying files.")
    for path, atomid in tqdm(locations.items()):
        parts = atomid.split("/")
        filename = os.path.basename(path)
        if len(parts) == 5: #archive
            target_path = f"{target_directory}/{parts[2]}/{parts[3]}/{parts[4]}"
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            shutil.copy(path, target_path + filename)
        else: #collection
            target_path = f"{target_directory}/COLLECTIONS/{parts[2]}/{parts[3]}"
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            shutil.copy(path, target_path + filename)


if __name__ == "__main__":
    p={
            "root_dir": ".", 
            "charter_dir": "{root_dir}/data/db/mom-data/metadata.charter.public", 
            "target_dir": "{root_dir}/data/tmp/data/leech_db",
            "file_ext": ".cei.xml"
            #TODO add "url2path_idx_path":"{root_dir}/url2path_idx.pickle" and respective code; this mean also checking when building directories whether it has already been done
    }
    args, _ = fargv.fargv(p) #Q: what is it that prevents improved linting for this module? e.g., when an arg is not in args -> p?; especially when nesting variables, e.g., building paths from root
    charter_paths = get_path_list(args.charter_dir, args.file_ext)
    atom_id_dict = get_charter_atomid_dict(charter_paths)
    move_files(atom_id_dict, args.target_dir)


# TODO: convention for docstring writing, see https://www.datacamp.com/tutorial/docstrings-python; and include datatypes